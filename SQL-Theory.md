# SQL-Theory

## 1.	Что такое SQL?
Язык структурированных запросов (SQL) – это язык программирования для хранения и обработки информации в реляционной базе данных. Реляционная база данных хранит информацию в табличной форме со строками и столбцами, представляющими различные атрибуты данных и различные связи между значениями данных. Инструкции SQL можно использовать для хранения, обновления, удаления, поиска и извлечения информации из базы данных. Можно также использовать SQL для поддержания и оптимизации производительности базы данных.
### Все SQL-команды делятся на четыре вида:
* DDL (Data Definition Language, или язык описания данных). Их используют, чтобы создавать, изменять и удалять целые таблицы.
* DML (Data Manipulation Language, или язык управления данными). Их применяют к содержимому таблиц, чтобы создавать, изменять, удалять атрибуты и записи. Если нужно получить какую-то информацию из базы данных, то пользуются именно DML-операторами.
* DCL (Data Control Language, или язык контроля данных). Они нужны, чтобы выдавать конкретным пользователям доступ к базам данных и отзывать его.
* TCL (Transaction Control Language, или язык контроля транзакций). Позволяет управлять транзакциями. Транзакция — это набор из нескольких команд, которые выполняются поочерёдно. Если одна из команд внутри транзакции не срабатывает, то все уже совершённые действия отменяются. То есть транзакция может быть совершена либо полностью, либо никак.
## 2.	Что такое БД?
База данных (БД) — это набор структурированных данных, предназначенный для хранения, обработки и изменения большого количества информации.
### Свойства базы данных
* У БД обязательно должно быть имя.
* БД может быть доступна только для чтения: пользователи считывают данные, но не могут изменять их или объекты БД.
* БД может выводить свое текущее состояние, которое нельзя отредактировать.
* Для БД можно включить шифрование и ограничить доступ.
* БД может фиксировать состояние объектов и их отношений в заданный момент времени.
* БД постоянна: данные безостановочно накапливаются и используются.
* БД подстраивается под новые данные и актуализируется.

## 3.	Какие бываю БД?
### Иерархические
Имеют древовидную схему, в которой корень (единый ствол) порождает множество расходящихся ветвей. Данные структурируются отношением «родитель-потомок». Примером иерархической базы служат файлы в вашем компьютере. Имеется основной диск, в котором лежат папки, содержащие другие папки. Физическая связь возможна путем взаимодействия с предыдущей папкой.
### Сетевые
В отличие от иерархической структуры у каждой записи может быть больше одного родителя. Используется не древовидная схема, а общий граф. Сетевой тип БД делит данные на два типа: узлы и ребра. Узлами называются объекты, а ребрами — связи между ними и их направления.
### Объектно-ориентированные
Расширение традиционных реляционных баз данных, в котором данные хранятся и обрабатываются в виде объектов. Объекты могут содержать также методы работы с данными, благодаря этому с данными можно работать эффективнее.
### Реляционные
Наиболее распространенный тип БД, где данные организованы в таблицах, а отношения между ними определяются с помощью ключей. В каждом столбце таблицы указывается атрибут объекта, о котором идет речь. Это может быть имя пользователя, род деятельности. Конкретный атрибут или комбинация атрибутов выбираются в качестве первичного ключа. Когда на ключ ссылаются другие таблицы, то он называется внешним ключом.

Реляционные БД поддерживают как модель «один ко многим», так и «многие ко многим».

#### Основные принципы реляционных БД:
* Все данные на концептуальном уровне представляются в виде объектов, заданных в виде строк и столбцов.
* В пересечение строки и столбца таблицы можно занести только одно значение.
* Все операции выполняются над целыми отношениями, и результатом этих операций является отношение.

Реляционные базы могут быть организованы по строкам или столбцам, что влияет на их оптимальное использование в различных сценариях: учет персонала и товаров, ведение бухгалтерии и электронного документооборота.

### Нереляционные (NoSQL)
Способны обрабатывать неструктурированные данные. Применяют несколько моделей в зависимости от типа обрабатываемых данных.

Нереляционные базы отлично подходят для обработки неструктурированных или полуструктурированных данных.

## 4.	В каком виде хранятся данные в Реляционных БД?
Реляционная база данных — это тип базы данных, в которой данные организованы в таблицы, и эти таблицы связаны на основе данных, общих для каждой из них. Эта структура позволяет выполнять гибкие сложные запросы одновременно ко многим таблицам.

### Структура реляционной базы данных
Реляционная база данных состоит из нескольких ключевых компонентов:
* таблицы. Это строительные блоки реляционной базы данных. Каждая таблица содержит данные об определенном объекте, таком как клиенты или продукты;
* поля. Это различные категории данных в каждой таблице, такие как «имя» или «электронная почта»;
* записи. Это отдельные записи в таблице. Каждая запись включает уникальный ключ, известный как первичный ключ, который идентифицирует эту запись;
* отношения. Это связи между таблицами, установленные с помощью общих данных, известных как внешние ключи.

## 5.	Что такое СУБД
Систе́ма управле́ния ба́зами да́нных (СУБД; англ. Database Management System), комплекс программ, которая позволяет создать базу данных (БД) и управлять данными (вставлять, обновлять, удалять и выбирать). Обеспечивает безопасность, надёжность хранения и целостность данных, а также предоставляет средства для администрирования БД.

Она позволяет упростить и автоматизировать процессы управления информацией, обеспечить ее безопасность и доступность в нужный момент.

СУБД позволяют пользователям создавать базы данных, определять структуру данных, взаимодействовать с данными через запросы и обеспечивать защиту информации. Они обеспечивают множество функций, таких как поддержка транзакций, согласованность данных, управление соединениями, оптимизация запросов и многое другое.

## 6.	Какие ты знаешь СУБД?
* Реляционные СУБД, такие как MySQL, Oracle, PostgreSQL и др., обычно используются для хранения структурированных данных в виде таблицы с реляционными связями. Они обеспечивают эффективное хранение, поиск и обновление данных.
* Нереляционные СУБД, такие как MongoDB, Cassandra, Redis и др., предназначены для хранения и обработки неструктурированных данных, таких как документы, графы, ключ-значение и другие. Они обычно быстрее и масштабируемее, чем реляционные СУБД.
* Временные СУБД используются для хранения и обработки временных данных, таких как журналы событий, временные серии данных и другие временные данные.
* Распределенные СУБД обеспечивают возможность хранить данные на нескольких физических серверах и выполнять параллельную обработку запросов. Это позволяет повысить производительность и масштабируемость системы.
* Встраиваемые СУБД, такие как SQLite или Berkley DB, используются для встроенного хранения данных в приложениях, не требуя установки дополнительного программного обеспечения или сервера базы данных. В целом, выбор определенного вида СУБД * * зависит от требований к производительности, масштабируемости, доступности данных, структуры данных и других факторов.
* Объектно-ориентированные СУБД: поддерживают хранение и обработку объектов, включая методы и атрибуты.
* Многомерные СУБД: используются для анализа данных с разных точек зрения.
* Графовые СУБД: основаны на графах, где данные представлены в виде узлов и связей между ними.

## 7.	Какая разница между MySQL и SQL?
SQL – это язык программирования, который можно использовать для запроса и обработки информации в реляционной базе данных, а также для добавления, обновления или извлечения данных в базе данных. В 1986 году Американский национальный институт стандартов присвоил SQL статус официального стандарта для реляционных баз данных. В 1987 году его примеру последовала Международная организация по стандартизации.

MySQL, в свою очередь, – это система управления реляционными базами данных. Вы можете использовать MySQL для хранения данных и управления ими с помощью таблиц в качестве системы управления реляционными базами данных. Можно создавать таблицы и определять отношения между ними. Вы также можете применять несколько методов, таких как индексы, транзакции и нормализация, для хранения и извлечения данных, сохраняя при этом их единообразие и точность. 

## 8.	Что такое первичный ключ (Primary key)?
Подробно Что такое первичный ключ (Primary key)
Первичный ключ (Primary Key) — это фундаментальное понятие в реляционных базах данных, которое играет ключевую роль в обеспечении уникальности и целостности данных в таблице. Вот подробное объяснение:

### Основные характеристики первичного ключа:
#### Уникальность:
Каждое значение в столбце первичного ключа должно быть уникальным. Это означает, что в таблице не может быть двух строк с одинаковым значением первичного ключа. Это гарантирует, что каждая запись в таблице будет однозначно идентифицирована.
#### Не допускает NULL значений:
Значение первичного ключа не может быть NULL. Каждая запись должна иметь конкретное значение в столбце первичного ключа.
#### Единственность:
В каждой таблице может быть только один первичный ключ, но он может состоять из одного или нескольких столбцов (составной ключ).
### Примеры использования первичного ключа:
##### Простой первичный ключ:
Один столбец используется в качестве уникального идентификатора.

    CREATE TABLE users (
      id INT PRIMARY KEY,
      name VARCHAR(100),
      email VARCHAR(100)
    );
В этом примере id является первичным ключом таблицы users.
##### Составной первичный ключ:
Несколько столбцов вместе образуют уникальный идентификатор.

    CREATE TABLE orders (
      order_id INT,
      product_id INT,
      PRIMARY KEY (order_id, product_id)
    );
В этом примере комбинация order_id и product_id образует составной первичный ключ таблицы orders.
### Зачем нужен первичный ключ:
#### Идентификация записей:
Уникально идентифицирует каждую запись в таблице, что облегчает поиск, обновление и удаление данных.
#### Обеспечение целостности данных:
Гарантирует, что каждая запись уникальна и нет дублирующихся данных.
#### Связи между таблицами:
Используется для создания связей между таблицами через внешние ключи (FOREIGN KEY). Внешний ключ в одной таблице ссылается на первичный ключ в другой таблице.
### Пример связи между таблицами с использованием первичного и внешнего ключа:
Таблица departments:

    CREATE TABLE departments (
      department_id INT PRIMARY KEY,
      department_name VARCHAR(50)
    );
Таблица employees:

    CREATE TABLE employees (
      employee_id INT PRIMARY KEY,
      first_name VARCHAR(50),
      last_name VARCHAR(50),
      department_id INT,
      FOREIGN KEY (department_id) REFERENCES departments(department_id)
    );
В этом примере department_id является первичным ключом в таблице departments и внешним ключом в таблице employees. Это позволяет создать связь между таблицами и обеспечить целостность данных.

## 9.	Что такое внешний ключ (Foreign key)?
Внешний ключ (Foreign Key) — это столбец или набор столбцов в одной таблице, который указывает на первичный ключ в другой таблице. Внешний ключ используется для установления и обеспечения ссылочной целостности между двумя таблицами, связывая их на уровне данных.
### Основные характеристики внешнего ключа:
#### Ссылочная целостность:
* Внешний ключ гарантирует, что значения в одной таблице соответствуют значениям в другой таблице.
* Он обеспечивает целостность данных, гарантируя, что каждая запись в дочерней таблице имеет соответствующую запись в родительской таблице.
#### Связи между таблицами:
* Внешний ключ устанавливает отношения между таблицами, такие как "один ко многим" и "многие ко многим".
* Пример: Связь между таблицами students и enrollments, где каждая запись в таблице enrollments ссылается на запись в таблице students.
### Пример внешнего ключа:
#### Создание таблиц с внешним ключом:
В этом примере мы создаем таблицу departments с первичным ключом и таблицу employees, которая имеет внешний ключ, указывающий на departments.

    CREATE TABLE departments (
      department_id INT PRIMARY KEY,
      department_name VARCHAR(50)
    );

    CREATE TABLE employees (
      employee_id INT PRIMARY KEY,
      first_name VARCHAR(50),
      last_name VARCHAR(50),
      department_id INT,
      FOREIGN KEY (department_id) REFERENCES departments(department_id)
    );
#### Добавление внешнего ключа в существующую таблицу:
Если таблица уже существует, можно добавить внешний ключ с помощью команды ALTER TABLE.

    ALTER TABLE employees
    ADD CONSTRAINT fk_department
    FOREIGN KEY (department_id)
    REFERENCES departments(department_id);
#### Примеры использования внешнего ключа:
##### Связь "один к одному":
* Каждой записи в первой таблице соответствует одна запись во второй таблице.
* Пример: Таблица person и таблица passport, где у каждого человека только один паспорт и у каждого паспорта только один владелец.
##### Связь "один ко многим":
* Каждой записи в первой таблице соответствует несколько записей во второй таблице.
* Пример: Таблица department и таблица employees, где каждый департамент может иметь много сотрудников.
##### Связь "многие ко многим":
* Каждой записи в первой таблице может соответствовать несколько записей во второй таблице, и наоборот.
* Пример: Таблицы students, courses и промежуточная таблица enrollments для хранения информации о том, какие студенты записаны на какие курсы.

      CREATE TABLE students (
        student_id INT PRIMARY KEY,
        student_name VARCHAR(50)
      );

      CREATE TABLE courses (
        course_id INT PRIMARY KEY,
        course_name VARCHAR(50)
      );

      CREATE TABLE enrollments (
        student_id INT,
        course_id INT,
        PRIMARY KEY (student_id, course_id),
        FOREIGN KEY (student_id) REFERENCES students(student_id),
        FOREIGN KEY (course_id) REFERENCES courses(course_id)
      );
### Зачем нужен внешний ключ:
#### Обеспечение целостности данных:
Внешний ключ гарантирует, что данные остаются согласованными между связанными таблицами. Например, нельзя добавить запись в дочернюю таблицу, если соответствующая запись отсутствует в родительской таблице.
#### Поддержание связей:
Внешний ключ позволяет управлять и поддерживать связи между различными таблицами в базе данных, облегчая навигацию и работу с данными.
#### Упрощение выполнения запросов:
Внешний ключ позволяет легко выполнять запросы, которые объединяют данные из связанных таблиц.

## 10.	Что такое реляции?
Реляции (или отношения) — это фундаментальная концепция реляционных баз данных, где данные организованы и управляются в виде таблиц. Эти таблицы состоят из строк и столбцов, и каждая строка представляет собой отдельную запись данных, а каждый столбец представляет собой атрибут данных. Давай углубимся в эту концепцию.
### Основные элементы реляционных баз данных:
#### Таблицы:
Таблицы — это основные структуры для хранения данных. В каждой таблице содержится информация об одном типе сущностей.
#### Столбцы (Атрибуты):
Атрибуты — это свойства или характеристики данных, хранящихся в таблице. Каждый атрибут соответствует столбцу таблицы.
#### Строки (Записи):
Каждая строка в таблице представляет собой отдельную запись данных. Эти записи часто называют туплами.
### Связи между реляциями:
Реляционные базы данных используют связи между таблицами для организации данных. Эти связи могут быть следующих типов:
#### Связь "один к одному" (1:1):
Каждой записи в одной таблице соответствует одна запись в другой таблице.
#### Связь "один ко многим" (1:N):
Каждой записи в первой таблице соответствует несколько записей во второй таблице.
#### Связь "многие ко многим" (M:N):
Каждой записи в первой таблице может соответствовать несколько записей во второй таблице, и наоборот.

## 11.	Зачем нужны реляции? приведи пример реляции как она вообще работает?
Реляции (или отношения) в реляционных базах данных (РБД) необходимы для структурирования и упорядочивания данных, а также для установления взаимосвязей между различными таблицами. Они обеспечивают целостность и согласованность данных, позволяют выполнять сложные запросы и анализировать информацию.
### Зачем нужны реляции:
#### Целостность данных:
Реляции обеспечивают целостность данных, гарантируя, что данные между связанными таблицами остаются согласованными. Например, нельзя добавить запись в дочернюю таблицу, если соответствующая запись отсутствует в родительской таблице.
#### Логическая организация:
Реляции позволяют логически организовать данные, разбивая информацию на отдельные таблицы, которые связаны между собой. Это делает данные более управляемыми и легче для понимания.
#### Эффективность запросов:
Реляции упрощают выполнение сложных запросов, которые объединяют данные из нескольких таблиц, позволяя легко анализировать и манипулировать данными.
### Типы связей между реляциями:
#### Связь "один к одному" (1:1):
* Каждой записи в одной таблице соответствует одна запись в другой таблице.
* Пример: Таблица passport и таблица person, где у каждого человека только один паспорт и у каждого паспорта только один владелец.

        CREATE TABLE person (
          person_id INT PRIMARY KEY,
          name VARCHAR(100)
        );

        CREATE TABLE passport (
          passport_id INT PRIMARY KEY,
          person_id INT,
          FOREIGN KEY (person_id) REFERENCES person(person_id)
        );
#### Связь "один ко многим" (1:N):
* Каждой записи в первой таблице соответствует несколько записей во второй таблице.
* Пример: Таблица department и таблица employees, где каждый департамент может иметь много сотрудников.

        CREATE TABLE department (
          department_id INT PRIMARY KEY,
          department_name VARCHAR(50)
        );

        CREATE TABLE employees (
          employee_id INT PRIMARY KEY,
          first_name VARCHAR(50),
          last_name VARCHAR(50),
          department_id INT,
          FOREIGN KEY (department_id) REFERENCES department(department_id)
        );
#### Связь "многие ко многим" (M:N):
* Каждой записи в первой таблице может соответствовать несколько записей во второй таблице, и наоборот.
* Пример: Таблицы students, courses и промежуточная таблица enrollments для хранения информации о том, какие студенты записаны на какие курсы.

        CREATE TABLE students (
          student_id INT PRIMARY KEY,
          student_name VARCHAR(50)
        );
        
        CREATE TABLE courses (
          course_id INT PRIMARY KEY,
          course_name VARCHAR(50)
        );
        
        CREATE TABLE enrollments (
          student_id INT,
          course_id INT,
          PRIMARY KEY (student_id, course_id),
          FOREIGN KEY (student_id) REFERENCES students(student_id),
          FOREIGN KEY (course_id) REFERENCES courses(course_id)
        );

## 12.	Что такое соединения в SQL?
Join — это операции, которые позволяют объединять строки из двух или более таблиц на основе логической связи между ними. Это позволяет извлекать связанные данные из разных таблиц в одном запросе.


## 13.	Какие ты  знаешь JOIN?
![](https://lh7-us.googleusercontent.com/docsz/AD_4nXfD-jXPCv_eyET49SS_Ljc3IDy8DTTSCA7_4GbGtAfnzQRim2g-AbmsP9B_jroaCHWdXbg7ciw1ABmmtqlk34flraZ7-0APQ9surGKlHseVJG6jnJC0CzWGOp389zI7gOVTwnqKYYP05Bb_YG0ZDQZaxJwvso59roxEVYRhl18IsiY9jfIAEg?key=e0vsqrxBogS9Vk79SX7BEQ)

### INNER JOIN:
Возвращает строки, которые имеют совпадения в обеих таблицах.
#### 📌Пример:

    SELECT students.name, courses.course_name
    FROM students
    INNER JOIN enrollments ON students.student_id = enrollments.student_id
    INNER JOIN courses ON enrollments.course_id = courses.course_id;
### LEFT JOIN (или LEFT OUTER JOIN):
Возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадения нет, возвращаются NULL значения для правой таблицы.
#### 📌Пример:

    SELECT students.name, courses.course_name
    FROM students
    LEFT JOIN enrollments ON students.student_id = enrollments.student_id
    LEFT JOIN courses ON enrollments.course_id = courses.course_id;
### RIGHT JOIN (или RIGHT OUTER JOIN):
Возвращает все строки из правой таблицы и совпадающие строки из левой таблицы. Если совпадения нет, возвращаются NULL значения для левой таблицы.
#### 📌Пример:

    SELECT students.name, courses.course_name
    FROM students
    RIGHT JOIN enrollments ON students.student_id = enrollments.student_id
    RIGHT JOIN courses ON enrollments.course_id = courses.course_id;
### FULL JOIN (или FULL OUTER JOIN):
Возвращает строки, которые имеют совпадения в одной из таблиц или обеих. Несовпадающие строки заполняются NULL значениями.
#### 📌Пример:

    SELECT students.name, courses.course_name
    FROM students
    FULL JOIN enrollments ON students.student_id = enrollments.student_id
    FULL JOIN courses ON enrollments.course_id = courses.course_id;
### CROSS JOIN:
Возвращает декартово произведение строк из обеих таблиц, то есть каждая строка одной таблицы объединяется с каждой строкой другой таблицы.
#### 📌Пример:

    SELECT students.name, courses.course_name
    FROM students
    CROSS JOIN courses;
    SELF JOIN:

### Соединение таблицы с самой собой для извлечения связанных данных из одной таблицы.
#### 📌Пример:

    SELECT a.name AS name1, b.name AS name2
    FROM employees a, employees b
    WHERE a.manager_id = b.employee_id;

## 14.	Расскажи подробно про FULL JOIN
FULL JOIN, или FULL OUTER JOIN, в SQL объединяет строки из двух таблиц и возвращает все строки, которые имеют совпадения в одной из таблиц или в обеих. Несовпадающие строки заполняются значениями NULL в тех местах, где нет совпадений. Это соединение полезно, когда нужно извлечь все данные, даже если некоторые строки не имеют соответствий.
### Основные характеристики FULL JOIN:
#### Объединение всех данных:
Возвращает все строки из обеих таблиц, независимо от наличия соответствий.
#### Заполнение NULL значениями:
Если для строки одной таблицы нет соответствующей строки в другой таблице, NULL значения заполняются для отсутствующих столбцов.
### 📌Пример использования FULL JOIN:
Предположим, у нас есть две таблицы: students (студенты) и courses (курсы).

    Таблица students:
    student_id | name
    -----------|---------
    1          | John
    2          | Jane
    3          | Alice

    Таблица courses:
    course_id | student_id | course_name
    ----------|------------|-------------
    101       | 1          | Math
    102       | 2          | Physics
    103       | 4          | Chemistry

    Запрос с использованием FULL JOIN:
    SELECT students.student_id, students.name, courses.course_name
    FROM students
    FULL JOIN courses ON students.student_id = courses.student_id;

    Результат:
    student_id | name  | course_name
    -----------|-------|-------------
    1          | John  | Math
    2          | Jane  | Physics
    3          | Alice | NULL
    NULL       | NULL  | Chemistry
### Что происходит в этом запросе:
* John и Jane имеют соответствия в обеих таблицах, поэтому они возвращаются с именами курсов.
* Alice не имеет соответствия в таблице courses, поэтому её строка заполняется NULL значением для столбца course_name.
* Chemistry не имеет соответствия в таблице students, поэтому её строка заполняется NULL значениями для столбцов student_id и name.

### Практическое применение FULL JOIN:
* FULL JOIN полезен, когда нужно собрать полный набор данных из двух таблиц, независимо от наличия соответствий. Например:
* Анализировать полный список студентов и курсов, чтобы найти несоответствия.
* Собрать данные из нескольких источников, где некоторые записи могут отсутствовать в одной из таблиц.

## 15.	Что такое Union?
![Uniom](https://www.google.com/url?sa=i&url=https%3A%2F%2Fbigtechinterviews.com%2Fsql-union-vs-union-all%2F&psig=AOvVaw3hYnLue203pBhcVAlnUNdZ&ust=1730381378288000&source=images&cd=vfe&opi=89978449&ved=0CBQQjRxqFwoTCLDy34ybtokDFQAAAAAdAAAAABAJ)

## 16.	В чем разница между UNION и UNION ALL ?
## 17.	Что такое SELECT ?
## 18.	Что такое подзапрос?
## 19.	Какая очередность выполнения когда есть подзапрос? что первым выполняется?
## 20.	Какие ограничения существуют при создании таблиц?
## 21.	Что такое Group By
## 22.	Что такое Order by?
## 23.	Что нужно указать что бы было по возрастанию или по убыванию в операторе Order by ?
## 24.	Что такое INSERT?
## 25.	Что такое Update?
## 26.	Какое отличие WHERE и HAVING
## 27.	Какие знаеш агрегатные функции?
## 28.	Для чего используются операторы IN, BETWEEN, LIKE?
## 29.	Какие условия выполнения операторов OR и AND
## 30.	Оператор SQL LIMIT
## 31.	Чем NULL отличается от 0
## 32.	В чем разница между операторами GROUP BY и DISTINCT?
## 33.	Что такое нормализация и каковы ее преимущества?
## 34.	Какие формы нормализации существуют?
## 35.	Что такое денормализация?
## 36.	Из каких подмножеств состоит SQL?
## 37.	Какие существуют типы связей в базе данных? Приведите примеры.
## 38.	Какие ты можешь использовать Числовые типы данных при создании таблици?
## 39.	Какие ты можешь использовать Текстовые типы данных при создании таблици?
## 40.	Какие ты можешь использовать типы данных Даты при создании таблици?
## 41.	В чем разница между типом данных CHAR и VARCHAR в SQL?
## 42.	Что бы работали джоины нужны ли реляции?
